# Kafka 내부 동작 이해하기 2 - 리더에포크 (LeaderEpoch)
* Kafka 파티션들의 **복구** 동작 시 **메시지의 일관성을 유지**하기 위한 용도로 사용
* 복구 동작 시 마지막 커밋 오프셋 위치를 대체하는 수단으로 활용

### 리더에포크와 복구

![kafka-last-offset-ex1](https://github.com/user-attachments/assets/43c2d060-adea-4d4c-ae98-1241968b1f06)

* 위 그림에서는 파티션 수를 1, 레플리케이션 팩터의 수는 2 라고 가정하며 장애가 발생하는 가정을 설명한다.
* 다음은 위 그림에 해당하는 동작 과정이다.

#### 장애 상황 예시
1. 리더는 프로듀서로부터 message 1 을 받고, 0번 오프셋에 저장 후 팔로워는 리더에게 0번 오프셋에 대한 가져오기 요청
2. 팔로워는 message 1을 리더로부터 레플리케이션
3. 리더의 오프셋 위치 1로 이동
4. 리더는 프로듀서로부터 message 2 를 받고, 1번 오프셋에 저장 후 팔로워는 리더에게 1번 오프셋에 대한 가져오기 요청
5. 가져오기 요청의 응답으로 리더의 마지막 오프셋 위치의 변화를 감지하고 자신의 오프셋 위치도 1로 이동
6. 팔로워는 message 2를 리더로부터 레플리케이션
7. 리더의 오프셋 위치를 2로 이동
8. **장애로 인해 팔로워가 다운**

* 위 상황은 팔로워가 message 2까지 레플리케이션을 완료했지만, 리더로부터 **오프셋 위치를 2로 올리라는 내용은 전달받지 못한 상태로 다운**되었다.
* 이런 다운된 상태에서 팔로워가 장애를 복구하는 과정은 다음과 같다.

#### 팔로워 오프셋 장애 복구 과정
![kafka-last-offset-ex2](https://github.com/user-attachments/assets/8ee66ae4-6db4-477a-82a0-32e127953559)

1. 팔로워는 자신의 오프셋보다 높은 메시지들은 신뢰하지 못한다고 판단하여 삭제한다. (위 예제에선 message 2 삭제)
2. 팔로워는 리더에게 1번 오프셋의 새로운 메시지를 가져오도록 요청한다.

#### 리더가 다운되는 장애 상황 예시
* 만약 위 복구 과정 중 팔로워가 리더에게 새로운 메시지를 가져오도록 요청한 순간에 리더가 다운된다면 어떻게 될까?
* 리더가 다운되면서 파티션에 유일하게 남아있는 팔로워가 새 리더로 승격된다.
  * 새 리더 (기존 팔로워)는 message 2를 손실한 채로 새 리더로 승격하게 되었다.
  * 이러면 **가용성**은 지켜졌지만, 데이터의 **일관성**이 지켜지지 않은 문제가 발생하는데, 이를 어떻게 해결할 수 있을까?

#### 리더에포크
* 이런 상황에서 사용되는 게 바로 **리더에포크**이다.
* 리더에포크를 사용하면 마지막 오프셋 위치보다 앞에 있는 메시지를 무조건 삭제하는 것이 아니라 리더에게 리더에포크 요청을 보낸다.

![kafka-last-offset-ex3](https://github.com/user-attachments/assets/66dd7a3b-b525-4f38-891f-0e1f63725fc6)

1. 팔로워는 복구 동작을 하면서 리더에게 리더에포크를 요청한다.
2. 요청을 받은 리더는 다운되기 전 리더의 마지막 오프셋 위치 전에 있는 메시지인 '1번 오프셋의 message 2'라고 요청을 보낸다.
3. 팔로워는 리더에포크의 응답을 확인 후 message 2 까지 자신의 오프셋 위치를 상향 조정한다.

### 리더에포크 정리
* 리더에포크를 통해 팔로워는 자신의 오프셋 위치를 올리면서 **메시지 손실**을 발생하지 않게 한다.
* 즉 리더에포크란 마지막 오프셋이라는 기준선을 넘겨버린 데이터들은 삭제하는 정책이 존재했는데, **기준선을 조정**하자는 정책으로 변경하자는 것이다.
