# Kafka 내부 동작 이해하기 1 - 레플리케이션 (Replication factor)
* 카프카는 브로커의 장애 상황에도 데이터 유실을 방지하며 안정적인 서비스를 제공한다.
* 가용성을 유지하는 환경을 구성하기 위해 Replication factor 옵션을 설정해서 복제 파티션을 만든다.
* 어떻게 레플리케이션이 동작하는지 알아본다.

### 리더와 팔로워
* 카프카는 내부적으로 모두 동일한 레플리케이션들을 리더와 팔로워로 구분하고 각자의 역할을 분담시킨다.
* 레플리케이션들 중 **리더를 하나 정하고 모든 읽기와 쓰기는 해당 리더를 통해서만 가능**하다.
* 메시지를 발행하는 **프로듀서는 리더에게만 메시지를 보낸다.**
* **컨슈머 또한 리더로부터 메시지를 가져온다.**

![kafka-leader-follower](https://github.com/user-attachments/assets/16861f55-39cc-4173-b4f0-e211aa39af00)

* 위 그림에서는 토픽의 파티션 수는 1개이고, 레플리케이션 팩터 수는 3개이다.
  * 토픽으로 메시지를 보내면 리더 파티션으로 메시지를 보내고, 컨슈머도 리더 파티션으로 메시지를 가져온다.
  * 팔로워 파티션들은 리더 파티션에 장애가 발생했는지 지속적으로 확인한다.
    * 리더 파티션이 **새로운 메시지를 받았는지 확인**, 새로운 메시지가 있다면 **복제**
  * 리더는 팔로워들이 위 확인 동작을 잘 하고 있는지 감시하고 이 중 장애로 인해 동작을 제대로 못하는 팔로워들은 리더 자격에서 박탈한다.
* 리더와 팔로워는 **ISR**(InSyncReplica) 라는 논리적 그룹으로 묶여 있어, 해당 그룹에 속한 팔로워들만이 새로운 리더 자격을 가질 수 있다.
  * ISR 내에서 **모든 팔로워에서 복제가 완료되면** 리더는 내부적으로 **커밋**을 하는데, 컨슈머는 **커밋된 메시지만 가져올 수 있다.**

![kafka-commit-whatif](https://github.com/user-attachments/assets/cddc8c8c-e6de-44f9-85e8-a35f12311af5)

* 프로듀서가 메시지를 리더에게 전달하면 즉시 컨슈머가 메시지를 가져오는 게 아니라 **내부적으로 복제를 모두 완료한 후 커밋을 한다.**
* 만약 그러지 않고 즉시 컨슈머가 메시지를 가져간다고 가정해보자 (위 그림)
  * 컨슈머 A는 리더로부터 message1, 2를 가져갔으며 현재 두 팔로워 파티션들은 아직 레플리케이션 동작을 하기 전이다.
  * 이 때 리더 파티션으로부터 장애가 발생했다 하고, 첫 번째 팔로워 파티션이 리더로 발탁되었다고 하자.
  * 컨슈머 B는 리더로 발탁된 팔로워로부터 메시지를 가져간다. 레플리케이션이 동작하기 전이라 message1 만 가져왔다.
  * 컨슈머 A와 B는 동일한 토픽에 컨슘했음에도 **메시지가 다른 문제가 발생한다.**

### 리더와 팔로워의 단계별 레플리케이션 동작
![kafka-replication-flow1](https://github.com/user-attachments/assets/f21f8e88-97cb-4776-888f-161e4ce506bd)

* 위 그림에서는 queue.topic 토픽에 1개의 파티션과 3개의 레플리케이션을 가지고 있다.
* 현재 리더 파티션에서는 message 1 메시지를 가지고 있고 팔로워 파티션에서는 아직 레플리케이션하기 전 상태라고 하자.

![kafka-replication-flow2](https://github.com/user-attachments/assets/39862727-06e9-45cf-85b9-7dc26abac061)

* 팔로워 파티션들이 레플리케이션을 동작하기 위해 리더 파티션에게 fetch 요청을 보낸 후, 새로운 메시지가 있다는 사실을 알아내고 레플리케이션이 된다.
* 정상적으로 레플리케이션이 되면 문제되지 않지만, 카프카에서는 **리더가 각 팔로워들이 레플리케이션 동작을 성공했는지 여부를 알지 못한다.**
  * 그럼 카프카에서는 레플리케이션 동작 실패를 어떻게 감지하고 다시 시도할까?

![kafka-replication-flow3](https://github.com/user-attachments/assets/98336604-997b-4fe3-9ad5-93fc06e46ef6)

* 만약 위 그림처럼 message 1은 팔로워에 모두 복제되었고, message 2를 리더가 프로듀서로부터 받았다고 가정하자.
* 각 팔로워들은 message 2에 해당하는 오프셋 1에 대한 레플리케이션을 리더에게 요청한다.
* 리더는 오프셋 1에 대한 요청이 왔으니 **오프셋 0은 정상적으로 레플리케이션 완료가 되었다고 인지한다.**
  * 만약 오프셋 0에 대한 레플리케이션이 실패했다면 오프셋 0에 대한 요청을 리더에게 했을 것이다.
* 즉 리더는 팔로워들이 보내는 **레플리케이션 요청의 오프셋을 보고 팔로워들이 어느 오프셋까지 성공했는지 인지한다.**

### RabbitMQ와 카프카의 차이
* RabbitMQ는 트랜잭션 모드에서 모든 팔로워가 메시지를 받았는지에 대한 ACK를 리더에게 전달해주면서 레플리케이션 동작을 확인한다.
* 카프카는 팔로워로부터 오는 오프셋에 대한 레플리케이션 요청으로 이전 오프셋이 정상적으로 레플리케이션 되었다는 사실을 인지한다.
* 카프카는 **리더와 팔로워 사이에 ACK 통신을 제거함으로써 레플리케이션 동작의 성능을 높인 것**이다.
