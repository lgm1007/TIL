# Kafka 컨슈머 리밸런싱
### 컨슈머 오프셋 관리
* 컨슈머에서 중요하게 처리하는 부분은 **오프셋 관리**
* 컨슈머가 컨슘하고 있는 토픽에서 메시지를 어디까지 들고왔는지 기록하고 있어야 함
* 컨슈머가 장애가 발생했을 때 새로운 컨슈머가 **기존 컨슈머의 마지막 메시지를 빠르게 가져올 수 있어야 장애를 빠르게 복구**할 수 있음

#### 오프셋
* 카프카에서는 메시지의 위치를 오프셋이라고 하는데, 이 정보들은 카프카에서 가장 안전한 장소인 **`__consumer_offsets` 토픽**에 각 컨슈머 그룹별로 오프셋 위치 정보가 기록된다.

![kafka_consumer_offsets](https://github.com/user-attachments/assets/85a916ba-1685-4a99-8854-dfbc6a1cc441)

* 위 그림은 컨슈머 그룹에서 `__consumer_offsets` 토픽에 컨슈머 그룹, 토픽, 파티션 등의 내용을 통합하여 오프셋 정보를 기록하는 모습이다.
* 여기서 저장되는 오프셋 값은 컨슈머가 마지막까지 읽은 위치가 아니라 **컨슈머가 다음으로 읽어야 하는 위치**이다.

### 그룹 코디네이터
* 컨슈머 그룹에는 여러 컨슈머들이 존재하는데, 기존에 존재하던 컨슈머가 이 그룹을 탈퇴하는 경우나 새로운 컨슈머가 해당 그룹을 합류하는 경우, 컨슈머 그룹은 변화를 인지하고 컨슘하고 있는 토픽의 메시지를 균등하게 분배해야 한다.
* 이렇게 동적으로 변화되는 컨슈머들에게 **작업을 균등하게 분배하는 동작**을 **컨슈머 리밸런싱**이라고 한다.
* 안정적인 컨슈머 그룹을 위해 별도의 코디네이터가 존재하는데, 이를 **그룹 코디네이터**라고 한다.
* 해당 코디네이터는 **구독한 토픽의 파티션과 그룹의 멤버들을 트래킹**하는 역할을 한다.
  * 즉 파티션 또는 그룹에 변화가 발생하면 **컨슈머 리밸런싱**이 발생하게끔
* 그룹 코디네이터와 컨슈머들은 서로 하트비트 (heartbeat) 를 주고 받는데, 이렇게 주기적으로 확인하면서 특정 컨슈머에 문제가 발생했다고 생각되면, 리밸런싱 동작을 수행한다.
* 아래는 하트비트를 활용하기 위한 옵션

|컨슈머 옵션|값|설명|
|---|---|---|
|heartbeat.interval.ms|3000|기본값은 3000이며, 그룹 코디네이터와 하트비트 인터벌 시간. <br/>해당 시간은 session.timeout.ms보다 낮게 설정해야 하며, 3분의 1 수준이 적절|
|session.timeout.ms|10000|기본값은 10000이며 어떤 컨슈머가 특정 시간 안에 하트비트를 받지 못하면 문제가 발생했다고 판단해 컨슈머 그룹에서 해당 컨슈머 제거되고 리밸런싱 동작|
|max.poll.interval.ms|300000|기본값은 300000이며, 컨슈머는 주기적으로 poll()을 호출해 토픽으로부터 레코드들을 가져오는데, poll() 호출 후 최대 5분간 poll() 호출이 없다면 컨슈머가 문제가 있는 것으로 판단해 리밸런싱 동작|

* **중요**: 리밸런싱이라는 동작은 **매우 높은 비용이 지불되는 작업**이므로 가급적 **리밸런싱이 자주 발생하지 않도록 주의**해야 한다.

